{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{424:function(s,n,a){\"use strict\";a.r(n);var e=a(1),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[n(\"p\",[s._v(\"本文已参与「新人创作礼」活动，一起开启掘金创作之路。\")]),s._v(\" \"),n(\"p\",[s._v(\"本篇，带你读懂async~await间的浪漫。\")]),s._v(\" \"),n(\"p\",[s._v(\"关于异步处理问题，ES5的回调让我们陷入回调地狱轮回，后来ES6的Promise（\"),n(\"a\",{attrs:{href:\"https://juejin.cn/post/7122028062702567455\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"Promise不了解？点这了解\"),n(\"OutboundLink\")],1),s._v(\"）让我们脱离轮回，终于，ES7的async-await带我们走向光明。今天我们就来学习一夏 async-await，看看与Promise有何联系和区别。\")]),s._v(\" \"),n(\"h2\",{attrs:{id:\"一、走进async-await原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、走进async-await原理\"}},[s._v(\"#\")]),s._v(\" 一、走进Async-await原理\")]),s._v(\" \"),n(\"h3\",{attrs:{id:\"_1、原理1\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、原理1\"}},[s._v(\"#\")]),s._v(\" 1、原理1\")]),s._v(\" \"),n(\"p\",[n(\"code\",[s._v(\"async函数返回一个 Promise 对象，可以使用then方法添加回调函数\")]),s._v(\"。举例说明：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// async返回的是Promise对象？\\nasync function testAsync() {\\n    return 'hello';//上篇文章Promise对象的返回值如果不是Promise，会通过Promise.resolve()转化为Promise，再进行处理\\n}\\nconst result = testAsync()\\nconsole.log(result);//Promise { 'hello' }  说明async返回的是Promise对象\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\")])]),n(\"p\",[s._v(\"那既然async返回的是Promise对象，那么async后面的函数可以接.then()或者.catch()...嘛？我们试一试就知道了。\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// async返回的是Promise对象,并且可以接Promise的方法？\\nasync function testAsync() {\\n    // await await等待还是promise对象\\n    return 'hello'\\n}\\ntestAsync()\\n    .then((result)=>{\\n        console.log(result);\\n    })\\n    .catch((error)=>{\\n        console.log(error);\\n    })\\n//hello  妈耶！打印了！说明async返回的是Promise对象，并且可以接Promise的方法，并且！！！默认状态是resolved的\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\")])]),n(\"p\",[s._v(\"上面代码说明，\"),n(\"code\",[s._v(\"async函数内部return语句返回的值，会成为then方法回调函数的参数\")])]),s._v(\" \"),n(\"h3\",{attrs:{id:\"_2、原理2\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、原理2\"}},[s._v(\"#\")]),s._v(\" 2、原理2\")]),s._v(\" \"),n(\"p\",[n(\"code\",[s._v(\"当async函数内部抛出错误的时候，会导致返回的 Promise 对象变为reject状态\")]),s._v(\"。抛出的错误对象会被.then()方法的第二个回调函数接收或者.catch()方法回调函数接收到。\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// async函数内部抛出错误或者Promise状态为reject\\nasync function testError(){\\n    //throw new Error('出错啦~~');\\n    await Promise.reject('出错了');//await前面有return和没有return效果一样\\n} \\ntestError()\\n    // .then(()=>{},(error)=>{console.log(error);})\\n    .catch(error=>{console.log(error);})\\n//Error: 出错啦~~\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\")])]),n(\"h3\",{attrs:{id:\"_3、原理3\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、原理3\"}},[s._v(\"#\")]),s._v(\" 3、原理3\")]),s._v(\" \"),n(\"p\",[n(\"code\",[s._v(\"await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值\")]),s._v(\"。代码说明：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// await\\nasync function getName(){\\n    // return '来自星星的你';\\n    return await '来自星星的你';//上面直接return等价于这个return\\n}\\ngetName()\\n    .then(result=>{console.log(result);})\\n//来自星星的你\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\")])]),n(\"h3\",{attrs:{id:\"_4、原理4\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、原理4\"}},[s._v(\"#\")]),s._v(\" 4、原理4\")]),s._v(\" \"),n(\"p\",[n(\"code\",[s._v(\"await的使用，必须要有async\")]),s._v(\"。这便是async-await的浪漫所在了：async返回的是一个Promise对象，await等待的就是这个Promise对象，所以await不能没有async（但是async可以没有await）。有没有被浪漫到？反正我是醉了。如果await没有async会怎么样？报错：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// await没有async会报错\\nfunction testAwait(){\\n    return await '西红柿炒辣椒'\\n}\\ntestAwait()\\n    .catch(error=>{\\n        console.log(error);\\n    })\\n//SyntaxError: await is only valid in async function\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\")])]),n(\"h2\",{attrs:{id:\"二、深入async-await规则\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、深入async-await规则\"}},[s._v(\"#\")]),s._v(\" 二、深入Async-await规则\")]),s._v(\" \"),n(\"h3\",{attrs:{id:\"_1、async封装promise\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、async封装promise\"}},[s._v(\"#\")]),s._v(\" 1、async封装Promise\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// async封装Promise\\nasync function fn1() {\\n    return '喜羊羊与灰太狼';// //相当于return Promise.resolve('喜羊羊与灰太狼')\\n    const data = await fn1();//接收data值\\n}\\nfn1()//执行async函数，返回的是一个Promise对象\\n    .then(data => {\\n        console.log('content =', data)\\n    })\\n​\\n//content = 喜羊羊与灰太狼\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\")])]),n(\"h3\",{attrs:{id:\"_2、await相当于then\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、await相当于then\"}},[s._v(\"#\")]),s._v(\" 2、await相当于then\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// await---.then()\\nasync function getName(){\\n    const operate=Promise.resolve('白雪公主')//执行函数\\n    const name= await operate //await相当于Promise的then  operate.then(name=>{})\\n    console.log('name:',name)\\n}\\ngetName();\\n( async function(){\\n    const person=await '七个小矮人' //await Promise.resolve('七个小矮人') await后面不跟Promise，也会被封装成Promise\\n    console.log('person:',person)//400\\n})();//自执行函数\\n​\\n//name: 白雪公主\\n//person: 七个小矮人\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),n(\"br\")])]),n(\"h3\",{attrs:{id:\"_3、多个await时-按时序执行\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、多个await时-按时序执行\"}},[s._v(\"#\")]),s._v(\" 3、多个await时，按时序执行\")]),s._v(\" \"),n(\"p\",[s._v(\"当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\"),n(\"code\",[s._v(\"任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行\")]),s._v(\"。\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"async function testOrder() {\\n    await Promise.reject('出错了')//UnhandledPromiseRejectionWarning: 出错了\\n    await Promise.resolve('hello world'); // 不会执行\\n}\\ntestOrder();\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\")])]),n(\"h3\",{attrs:{id:\"_4、try-catch相当于catch\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、try-catch相当于catch\"}},[s._v(\"#\")]),s._v(\" 4、try…catch相当于catch\")]),s._v(\" \"),n(\"p\",[s._v(\"如果希望即使前一个异步操作失败，也不要中断后面的异步操作。可\"),n(\"code\",[s._v(\"将第一个await放在try...catch结构里面\")]),s._v(\"，这样不管这个异步操作是否成功，第二个await都会执行。\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// try...catch\\n!(async function () {\\n    const testError = Promise.reject('出错啦~~~')//rejected状态\\n    // const testError=throw new Error('出错啦~~~');\\n    try {\\n        const result = await testError; //await相当于then，但是reject不会触发then\\n        console.log('success:'+result) //不会输出，因为const result = await testError被报错，被catch捕获\\n    } catch (error) {\\n        console.error('error:'+error)//try...catch 相当于Promise的catch\\n    }\\n​\\n})()\\n//error:出错啦~~~\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\")])]),n(\"p\",[s._v(\"当await后面是Promise对象的时候，我们\"),n(\"code\",[s._v(\"也可直接在await后面直接.catch捕获\")]),s._v(\"错误：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"async function testError() {\\n    await Promise.reject('出错了')\\n        .catch(error => console.log(error));//这里捕获错误，不会影响下一个await执行\\n    \\n    return await Promise.resolve('hello world');\\n}\\n​\\ntestError()\\n    .then(result => console.log(result))\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\")])]),n(\"h2\",{attrs:{id:\"三、解析async-await语法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、解析async-await语法\"}},[s._v(\"#\")]),s._v(\" 三、解析Async-await语法\")]),s._v(\" \"),n(\"p\",[s._v(\"我们浅浅看一个面试题：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// 面试题\\nfunction getJSON() {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            console.log(2);\\n            resolve(2)\\n        }, 2000)\\n    })\\n}\\nasync function testAsync() {\\n    await getJSON()\\n    console.log(3);\\n}\\ntestAsync()\\n//2\\n//3\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),n(\"br\")])]),n(\"p\",[s._v(\"问题当然不会问打印顺序啦，问题是将async await语句解析翻译为Promise？\")]),s._v(\" \"),n(\"p\",[s._v(\"根据现在的知识面，我们必须知道：\")]),s._v(\" \"),n(\"blockquote\",[n(\"p\",[s._v(\"（1）await不能单独出现，其函数前面一定要有async。\")]),s._v(\" \"),n(\"p\",[s._v(\"（2）await会干两件事：\")]),s._v(\" \"),n(\"p\",[s._v(\"第一，将写在await后面的代码放到async创建的那个Promise里面执行。\")]),s._v(\" \"),n(\"p\",[s._v(\"第二、将写在await下面的代码放到前一个创建的那个Promise对象的.then里面执行。\")]),s._v(\" \"),n(\"p\",[s._v(\"（3）await返回的也是Promise对象，他只是把await下面的代码放到了await返回的promise的.then里面执行。\")])]),s._v(\" \"),n(\"p\",[s._v(\"这样的话，是不是如鱼得水了。翻译如下：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"function getJSON() {\\n    return new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n            console.log(2);\\n            resolve(2)\\n        }, 2000)\\n    })\\n}\\n// 编译成Promise原理\\nfunction testAsync() {\\n    return Promise.resolve().then(() => {\\n        return getJSON();\\n    })\\n        .then(() => {\\n            console.log(3);\\n​\\n        })\\n}\\ntestAsync()\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),n(\"br\")])]),n(\"h2\",{attrs:{id:\"四、拓展async-await应用\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、拓展async-await应用\"}},[s._v(\"#\")]),s._v(\" 四、拓展Async-await应用\")]),s._v(\" \"),n(\"h3\",{attrs:{id:\"_1、场景1\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、场景1\"}},[s._v(\"#\")]),s._v(\" 1、场景1\")]),s._v(\" \"),n(\"p\",[s._v(\"你学废async-await了嘛？还记得上一篇开篇的回调地狱嘛？我们通过Promise解决回调是这样的：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"// Promise解决方式\\nfunction doCallback(n) {\\n    var myPromise = new Promise(function (resolve, reject) {   \\n        //处理异步任务\\n        var flag = true;\\n        setTimeout(function () {\\n            if (flag) {\\n                resolve(n)\\n            }\\n            else {\\n                reject('失败')\\n            }\\n        },0)\\n    })\\n    return myPromise;\\n}\\n​\\ndoCallback(1)\\n    .then((result) => { //then是成功执行的方法 返回的还是一个Promise对象\\n        console.log(result);//打印张三  res是执行\\n        return fn(2);\\n    })\\n    .then((result) => {\\n        console.log(result);\\n        return fn(3)\\n    })\\n    .then((result) => {\\n        console.log(result);\\n        return fn(4)\\n    })\\n    .then((result) => {\\n        console.log(result);\\n    })\\n    .catch((result) => { //catch是失败执行的方法\\n        console.log(result);\\n    })\\n    //好多.then,形成.then链啦\\n//1\\n//2\\n//3\\n//4\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"26\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"27\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"28\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"29\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"30\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"31\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"32\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"33\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"34\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"35\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"36\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"37\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"38\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"39\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"40\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"41\")]),n(\"br\")])]),n(\"p\",[s._v(\"通过以上Promise方法，可以明显解决回调地狱“向右移”的浮夸表现，但是，\"),n(\"code\",[s._v(\"Promise是基于 then, catch 的链式调用，但也是基于回调函数\")]),s._v(\"。.then链多多少少还是违背原生代码，显得也不是很优雅。作为回调终极武器，async-await更加贴近于原生代码，我们看一下吧：\")]),s._v(\" \"),n(\"div\",{staticClass:\"language- line-numbers-mode\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[s._v(\"//封装一个返回promise的异步任务\\nfunction doCallback(str) {\\n    var myPromise = new Promise(function (resolve, reject) {\\n        var flag = true;\\n        setTimeout(function () {\\n            if (flag) {\\n                resolve(str)\\n            } else {\\n                reject('处理失败')\\n            }\\n        })\\n    })\\n    return myPromise;\\n}\\n​\\n//封装一个执行上述异步任务的async函数\\nasync function testAsync() {\\n    var result1 = await doCallback(1);  //await直接拿到fn()返回的promise的数据，并且赋值给result\\n    var result2 = await doCallback(2);  //await 后面的代码，都可以看做是异步回调 callback 里的内容，都是异步的\\n    var result3 = await doCallback(3);\\n    var result4 = await doCallback(4);\\n    console.log(result1);\\n    console.log(result2);\\n    console.log(result3);\\n    console.log(result4);\\n}//这样是不是简洁优雅多了呢？\\n//执行函数\\ntestAsync();\\n//1\\n//2\\n//3\\n//4\\n\")])]),s._v(\" \"),n(\"div\",{staticClass:\"line-numbers-wrapper\"},[n(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"26\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"27\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"28\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"29\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"30\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"31\")]),n(\"br\"),n(\"span\",{staticClass:\"line-number\"},[s._v(\"32\")]),n(\"br\")])]),n(\"p\",[s._v(\"有了 async-await、promise 还有必要学习吗？通过上面async-await的解决方案可以瞧见，\"),n(\"code\",[s._v(\"async / await 和 Promise 并不互斥，二者相辅相成\")]),s._v(\"。同时async / await 并不能改变异步的本质（ js是单线程的，异步需要回调，都是要基于 event loop 来实现(什么是event loop?关注我，等我文章~)）。\")]),s._v(\" \"),n(\"h2\",{attrs:{id:\"总结\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[s._v(\"#\")]),s._v(\" 总结\")]),s._v(\" \"),n(\"p\",[s._v(\"现在知道了，async-await是promise的语法糖了吧，不仅让我们书写代码时更加流畅，而且增强了代码的可读性。特别注意的是：虽然async-await 是建立在 Promise机制之上的，但是并不能取代其地位，他们两者相辅相成，息息相关。其实async-await不止是Promise的语法糖，还是Generator的语法糖，Generator是什么？我们下篇见分晓。\")]),s._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1c37fd40504326b72a86918f41e6f0~tplv-k3u1fbpfcp-watermark.image?\",alt:\"heiehi.webp\"}})])])}),[],!1,null,null,null);n.default=t.exports}}]);","extractedComments":[]}